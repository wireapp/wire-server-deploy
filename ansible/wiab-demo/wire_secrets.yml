- name: Create wire secrets
  hosts: deploy_node
  become_user: "{{ ansible_user }}"
  become: yes
  vars:
    secrets_file: "{{ ansible_user_dir }}/wire-server-deploy/values/wire-server/secrets.yaml"
  tasks:

  - name: Checking if secrets have been pre-created
    block:
    - name: Check if wire_secrets file exists
      stat:
        path: "{{ ansible_user_dir }}/wire_secrets"
      register: wire_secrets_file_stat

    - name: Read stored secret hash from file
      slurp:
        src: "{{ ansible_user_dir }}/wire_secrets"
      register: stored_secrets_hash
      when: wire_secrets_file_stat.stat.exists

    - name: Check if secrets.yaml file exists
      stat:
        path: "{{ secrets_file }}"
      register: secrets_yaml_stat

    - name: Fail if secrets.yaml file doesn't exist
      fail:
        msg: |
          The secrets file '{{ secrets_file }}' is required but was not found.
          This playbook requires the Wire values (and secrets) files to be prepared beforehand.
          Please ensure that wire_values.yml (tag wire_values) playbook has been executed before running this playbook.
          Refer to the deployment documentation for
           proper sequencing of playbooks.
      when: not secrets_yaml_stat.stat.exists

    # a heuristic approach here to verify against one of the secrets only to check if secrets were generated or not
    - name: Extract and hash current turn secret value
      block:
        - name: Read secrets file from remote
          slurp:
            src: "{{ secrets_file }}"
          register: secrets_file_slurp

        - name: Parse and calculate hash of turn secret
          set_fact:
            current_secret_hash: "{{ (secrets_file_slurp.content | b64decode | from_yaml).brig.secrets.turn.secret | hash('sha256') }}"
      when: secrets_yaml_stat.stat.exists

    - name: Compare stored hash with current secret hash (only if file exists)
      set_fact:
        skip_secret_generation: "{{ stored_secrets_hash.content | b64decode | trim == current_secret_hash }}"
      when: wire_secrets_file_stat.stat.exists

    - name: Set skip flag to false if wire_secrets file doesn't exist
      set_fact:
        skip_secret_generation: false
      when: not wire_secrets_file_stat.stat.exists

  - name: Generate wire secrets and update configuration
    block:

    - name: Prepare secrets.yaml files for the demo environment
      shell: source {{ ansible_user_dir }}/wire-server-deploy/bin/wiab-demo/offline_deploy_k8s.sh && process_charts demo secrets
      args:
        executable: /bin/bash
      environment:
        BASE_DIR: "{{ ansible_user_dir }}/wire-server-deploy"

    - name: Generate random strings for zrest, minio_access_key, and minio_secret_key
      shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c {{ item.length }}"
      register: random_strings
      changed_when: false
      with_items:
        - { name: 'zrest', length: 64 }
        - { name: 'minio_access_key', length: 20 }
        - { name: 'minio_secret_key', length: 42 }

    - name: Set generated random strings as facts
      set_fact:
        "{{ item.item.name }}": "{{ item.stdout }}"
      with_items: "{{ random_strings.results }}"

    - name: Check if ZAUTH Docker image already exists
      shell: docker images | grep "quay.io/wire/zauth" | awk '{print $1":"$2}' | head -1
      register: existing_zauth_image
      failed_when: false
      changed_when: false

    - name: find zauth container image file (if image not already present)
      shell: find "{{ ansible_user_dir }}/wire-server-deploy/containers-adminhost/" -name "quay.io_wire_zauth_*.tar" -type f | head -1
      register: zauth_docker_image
      when: existing_zauth_image.stdout == ""

    - name: Load ZAUTH Docker image (if not already present)
      shell: |
        docker load -i "{{ zauth_docker_image.stdout }}" | awk '{print $3}'
      register: loaded_zauth_container
      when: existing_zauth_image.stdout == ""

    - name: Set ZAUTH container image name
      set_fact:
        zauth_container:
          stdout: "{{ existing_zauth_image.stdout if existing_zauth_image.stdout != '' else loaded_zauth_container.stdout }}"

    - name: Generate zauth keypair
      shell: docker run "{{ zauth_container.stdout }}" -m gen-keypair
      register: zauth_output
      changed_when: false
      ignore_errors: true
    
    - name: Fallback - Generate zauth keypair with index
      shell: docker run "{{ zauth_container.stdout }}" -m gen-keypair -i 1
      register: zauth_output_fallback
      changed_when: false
      when: zauth_output is failed

    - name: Use fallback output if initial failed
      set_fact:
        zauth_output: "{{ zauth_output_fallback }}"
      when: zauth_output is failed

    - name: Extract zauth keys
      set_fact:
        zauth_public: "{{ zauth_output.stdout_lines[0].split()[1] }}"
        zauth_private: "{{ zauth_output.stdout_lines[1].split()[1] }}"

    - name: Update minio (fake-aws-s3) access key and secret
      block:
        - name: Read fake-aws values from remote
          slurp:
            src: "{{ ansible_user_dir }}/wire-server-deploy/values/fake-aws/values.yaml"
          register: fake_aws_slurp

        - name: Update minio credentials
          set_fact:
            fake_aws_values: "{{ (fake_aws_slurp.content | b64decode | from_yaml) | combine(minio_update, recursive=True) }}"
          vars:
            minio_update:
              fake-aws-s3:
                minio:
                  users:
                    - accessKey: "{{ minio_access_key }}"
                      secretKey: "{{ minio_secret_key }}"
                      policy: "consoleAdmin"

        - name: Write fake-aws values to file
          copy:
            content: "{{ fake_aws_values | to_nice_yaml }}"
            dest: "{{ ansible_user_dir }}/wire-server-deploy/values/fake-aws/values.yaml"

    - name: Update secrets for wire-server
      block:
        - name: Read current secrets.yaml from remote
          slurp:
            src: "{{ secrets_file }}"
          register: secrets_slurp

        - name: Update secrets in-place
          set_fact:
            secrets: "{{ (secrets_slurp.content | b64decode | from_yaml) | combine(update_dict, recursive=True) }}"
          vars:
            update_dict:
              brig:
                secrets:
                  turn:
                    secret: "{{ zrest }}"
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
                    privateKeys: "{{ zauth_private }}"
              nginz:
                secrets:
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
              cargohold:
                secrets:
                  awsKeyId: "{{ minio_access_key }}"
                  awsSecretKey: "{{ minio_secret_key }}"

        - name: Write updated secrets to file
          copy:
            content: "{{ secrets | to_nice_yaml }}"
            dest: "{{ secrets_file }}"

    - name: Update secrets for coturn
      block:
        - name: Read current coturn secrets from remote
          slurp:
            src: "{{ ansible_user_dir }}/wire-server-deploy/values/coturn/secrets.yaml"
          register: coturn_slurp

        - name: Update coturn zrestSecrets
          set_fact:
            coturn_secrets: "{{ (coturn_slurp.content | b64decode | from_yaml) | combine({'secrets': {'zrestSecrets': [zrest]}}, recursive=True) }}"

        - name: Write updated coturn secrets to file
          copy:
            content: "{{ coturn_secrets | to_nice_yaml }}"
            dest: "{{ ansible_user_dir }}/wire-server-deploy/values/coturn/secrets.yaml"

    - name: Store current secret hash for future comparison
      block:
        - name: Read secrets file from remote
          slurp:
            src: "{{ secrets_file }}"
          register: secrets_for_hash_slurp

        - name: Calculate and store hash
          copy:
            content: "{{ (secrets_for_hash_slurp.content | b64decode | from_yaml).brig.secrets.turn.secret | hash('sha256') }}"
            dest: "{{ ansible_user_dir }}/wire_secrets"

    when: not skip_secret_generation

  - name: Secrets already up-to-date message
    debug:
      msg: "Wire secrets already up-to-date. Skipping regeneration."
    when: skip_secret_generation
