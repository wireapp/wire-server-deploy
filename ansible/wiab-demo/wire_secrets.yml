- name: Create wire secrets
  hosts: deploy_node
  vars:
    wire_server_secrets_file: "{{ values_dir }}/wire-server/secrets.yaml"
    wire_secret_path: "{{ wire_vars }}/wire_secrets"
  tasks:

  - name: Validate required variables are defined
    assert:
      that:
        - charts_to_deploy is defined
        - additional_charts is defined
        - values_dir is defined
        - kube_config is defined
        - wire_vars is defined
      fail_msg: |
        Required variables not defined:
        - charts_to_deploy: {{ charts_to_deploy | default('UNDEFINED') }}
        - additional_charts: {{ additional_charts | default('UNDEFINED') }}
        - values_dir: {{ values_dir | default('UNDEFINED') }}
        - kube_config: {{ kube_config | default('UNDEFINED') }}
        - wire_vars: {{ wire_vars | default('UNDEFINED') }}
      quiet: yes

  - name: Determine secret generation skip status
    block:
    - name: Check if wire_secrets file exists
      stat:
        path: "{{ wire_secret_path }}"
      register: wire_secrets_file_stat

    - name: Read stored secret hash from file
      slurp:
        src: "{{ wire_secret_path }}"
      register: stored_secrets_hash
      when: wire_secrets_file_stat.stat.exists

    - name: Check if secrets.yaml file exists
      stat:
        path: "{{ wire_server_secrets_file }}"
      register: secrets_yaml_stat

    - name: Set skip flag to false if secrets.yaml or secret_hash file doesn't exist
      set_fact:
        skip_secret_generation: false
      when: ((not secrets_yaml_stat.stat.exists) or (not wire_secrets_file_stat.stat.exists))

    # Uses zAuth public key as idempotency marker since it uniquely identifies secret generation
    - name: Determine skip status by comparing secret hashes
      block:
      - name: Read secrets file from remote
        slurp:
          src: "{{ wire_server_secrets_file }}"
        register: secrets_file_slurp

      - name: Parse and calculate hash of Zauth Publickey
        set_fact:
          current_secret_hash: "{{ (secrets_file_slurp.content | b64decode | from_yaml).brig.secrets.zAuth.publicKeys | hash('sha256') }}"
        ignore_errors: true

      - name: Set skip flag to false if secret key is missing
        set_fact:
          skip_secret_generation: false
        when: current_secret_hash is undefined

      - name: Detect if secrets are unchanged by comparing hashes
        set_fact:
          skip_secret_generation: "{{ (stored_secrets_hash.content | b64decode | trim) == current_secret_hash }}"
        when: current_secret_hash is defined
      when:
      - secrets_yaml_stat.stat.exists
      - wire_secrets_file_stat.stat.exists

  - name: Initialize secrets.yaml files from demo templates
    block:
    - name: Find all demo-secrets.example.yaml files in one pass
      find:
        paths: "{{ values_dir }}"
        patterns: "demo-secrets.example.yaml"
        recurse: yes
      register: demo_secrets_files
      changed_when: false

    - name: Backup and initialize secrets for all charts
      shell: |
        #!/bin/bash
        set -e
        demo_file="{{ item }}"
        chart_dir="$(dirname "$demo_file")"
        secrets_file="$chart_dir/secrets.yaml"
        
        # Create timestamped backup if secrets.yaml exists
        if [ -f "$secrets_file" ]; then
          backup_file="${secrets_file}.bak.$(date +%Y%m%d_%H%M%S)"
          mv "$secrets_file" "$backup_file"
          echo "Backed up: $backup_file"
        fi
        
        # Copy demo template to secrets.yaml
        cp "$demo_file" "$secrets_file"
        echo "Initialized: $secrets_file"
      args:
        executable: /bin/bash
      register: init_result
      changed_when: "'Initialized:' in init_result.stdout"
      loop: "{{ demo_secrets_files.files | map(attribute='path') | list }}"
      no_log: true

    - name: Display backup and initialization summary
      debug:
        msg: "{{ init_result.results | map(attribute='stdout_lines') | flatten | list }}"
      when: init_result.results | length > 0

    when: not skip_secret_generation

  - name: Generate wire secrets and update configuration
    block:
    - name: Generate random strings for zrest, minio_access_key, and minio_secret_key
      shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c {{ item.length }}"
      register: random_strings
      changed_when: false
      with_items:
        - { name: 'zrest', length: 64 }
        - { name: 'minio_access_key', length: 20 }
        - { name: 'minio_secret_key', length: 42 }

    - name: Set generated random strings as facts
      set_fact:
        "{{ item.item.name }}": "{{ item.stdout }}"
      with_items: "{{ random_strings.results }}"
      no_log: true

    - name: Validate all secrets were generated with correct length
      assert:
        that:
          - zrest is defined and zrest | length == 64
          - minio_access_key is defined and minio_access_key | length == 20
          - minio_secret_key is defined and minio_secret_key | length == 42
        fail_msg: |
          Secret generation failed:
          - zrest length: {{ zrest | length if zrest is defined else 'UNDEFINED' }} (expected 64)
          - minio_access_key length: {{ minio_access_key | length if minio_access_key is defined else 'UNDEFINED' }} (expected 20)
          - minio_secret_key length: {{ minio_secret_key | length if minio_secret_key is defined else 'UNDEFINED' }} (expected 42)
        quiet: yes

    - name: Generate Ed25519 cryptographic keys for zauth
      block:
      - name: Create temporary directory for key files
        tempfile:
          state: directory
          suffix: _zauth_keys
        register: zauth_temp_dir
        changed_when: false

      - name: Set temp_dir fact from tempfile result
        set_fact:
          temp_dir: "{{ zauth_temp_dir.path }}"

      - name: Generate Ed25519 private key using openssl
        shell: "openssl genpkey -algorithm ed25519 -out '{{ temp_dir }}/key.pem'"
        changed_when: false

      - name: Extract private key in DER format
        shell: "openssl pkey -in '{{ temp_dir }}/key.pem' -outform DER 2>/dev/null > '{{ temp_dir }}/priv.der'"
        changed_when: false

      - name: Extract last 32 bytes of private DER (private seed)
        shell: "tail -c 32 '{{ temp_dir }}/priv.der' > '{{ temp_dir }}/priv.bytes'"
        changed_when: false

      - name: Extract public key in DER format
        shell: "openssl pkey -in '{{ temp_dir }}/key.pem' -pubout -outform DER 2>/dev/null > '{{ temp_dir }}/pub.der'"
        changed_when: false

      - name: Extract last 32 bytes of public DER (public key)
        shell: "tail -c 32 '{{ temp_dir }}/pub.der' > '{{ temp_dir }}/pub.bytes'"
        changed_when: false

      - name: Combine private seed and public key for libsodium format (64 bytes total)
        shell: "cat '{{ temp_dir }}/priv.bytes' '{{ temp_dir }}/pub.bytes' > '{{ temp_dir }}/combined.bytes'"
        changed_when: false

      - name: Encode combined key to base64 (private key)
        shell: "base64 -w 0 < '{{ temp_dir }}/combined.bytes' | tr -- '+/' '-_'"
        register: libsodium_priv
        changed_when: false

      - name: Encode public key to base64
        shell: "base64 -w 0 < '{{ temp_dir }}/pub.bytes' | tr -- '+/' '-_'"
        register: libsodium_pub
        changed_when: false

      - name: Validate extracted key byte lengths
        block:
          - name: Get private key byte length
            shell: "wc -c < '{{ temp_dir }}/priv.bytes'"
            register: priv_bytes_len
            changed_when: false

          - name: Get public key byte length
            shell: "wc -c < '{{ temp_dir }}/pub.bytes'"
            register: pub_bytes_len
            changed_when: false

          - name: Assert key lengths are correct
            assert:
              that:
                - priv_bytes_len.stdout | int == 32
                - pub_bytes_len.stdout | int == 32
              fail_msg: |
                Key extraction failed:
                - Private seed length: {{ priv_bytes_len.stdout }} (expected 32)
                - Public key length: {{ pub_bytes_len.stdout }} (expected 32)
              quiet: yes

      - name: Validate base64 encoded keys format
        block:
          - name: Verify private key is valid base64
            assert:
              that:
                - libsodium_priv.stdout is regex('^[A-Za-z0-9_-]+=*$')
              fail_msg: "Private key is not valid base64: {{ libsodium_priv.stdout }}"
              quiet: yes

          - name: Verify public key is valid base64
            assert:
              that:
                - libsodium_pub.stdout is regex('^[A-Za-z0-9_-]+=*$')
              fail_msg: "Public key is not valid base64: {{ libsodium_pub.stdout }}"
              quiet: yes

      - name: Validate decoded key lengths
        block:
          - name: Decode and verify private key length (should be 64 bytes)
            shell: "printf '%s' '{{ libsodium_priv.stdout }}' | tr -- '-_' '+/' | base64 -d | wc -c"
            register: priv_decoded_len
            changed_when: false

          - name: Decode and verify public key length (should be 32 bytes)
            shell: "printf '%s' '{{ libsodium_pub.stdout }}' | tr -- '-_' '+/' | base64 -d | wc -c"
            register: pub_decoded_len
            changed_when: false

          - name: debug
            debug:
              msg: " {{libsodium_pub.stdout}} {{libsodium_priv.stdout }}"

          - name: Assert decoded key lengths are correct
            assert:
              that:
                - priv_decoded_len.stdout | int == 64
                - pub_decoded_len.stdout | int == 32
              fail_msg: |
                Decoded key length validation failed:
                - Private key decoded length: {{ priv_decoded_len.stdout }} (expected 64)
                - Public key decoded length: {{ pub_decoded_len.stdout }} (expected 32)
              quiet: yes

      - name: Set zauth keys as facts
        set_fact:
          zauth_private: "{{ libsodium_priv.stdout }}"
          zauth_public: "{{ libsodium_pub.stdout }}"
        no_log: true

      always:
      - name: Cleanup temporary directory
        file:
          path: "{{ zauth_temp_dir.path }}"
          state: absent
        changed_when: false
        when: zauth_temp_dir.path is defined

    - name: Configure minio credentials for fake-aws-s3 secrets
      block:
      - name: Check if fake-aws secrets file exists
        stat:
          path: "{{ values_dir }}/fake-aws/secrets.yaml"
        register: fake_aws_secrets_stat

      - name: Create empty fake-aws secrets file if it doesn't exist
        copy:
          content: "fake-aws-s3: {}\n"
          dest: "{{ values_dir }}/fake-aws/secrets.yaml"
        when: not fake_aws_secrets_stat.stat.exists

      - name: Read fake-aws values from remote
        slurp:
          src: "{{ values_dir }}/fake-aws/secrets.yaml"
        register: fake_aws_slurp

      - name: Update minio credentials
        set_fact:
          fake_aws_values: "{{ (fake_aws_slurp.content | b64decode | from_yaml) | combine(minio_update, recursive=True) }}"
        vars:
          minio_update:
            fake-aws-s3:
              minio:
                users:
                  - accessKey: "{{ minio_access_key }}"
                    secretKey: "{{ minio_secret_key }}"
                    policy: "consoleAdmin"

      - name: Write fake-aws values to file
        copy:
          content: "{{ fake_aws_values | to_nice_yaml }}"
          dest: "{{ values_dir }}/fake-aws/secrets.yaml"

    - name: Generate PostgreSQL credentials and create Kubernetes secret
      block:
      - name: Check if wire-postgresql-secret already exists in Kubernetes
        kubernetes.core.k8s_info:
          kind: Secret
          name: wire-postgresql-secret
          namespace: default
          kubeconfig: "{{ kube_config }}"
        register: existing_pg_secret
        retries: 3
        delay: 2
        until: existing_pg_secret is not failed

      - name: Extract existing PostgreSQL credentials from Kubernetes secret
        set_fact:
          pgpassword: "{{ (existing_pg_secret.resources[0].data.password | b64decode) }}"
          pgadmin: "{{ (existing_pg_secret.resources[0].data['postgres-password'] | b64decode) }}"
        no_log: true
        when: existing_pg_secret.resources | length > 0

      - name: Generate new random strings for PostgreSQL passwords if secret doesn't exist
        shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c {{ item.length }}"
        register: pg_random_strings
        changed_when: false
        no_log: true
        with_items:
          - { name: 'pgpassword', length: 32 }
          - { name: 'pgadmin', length: 32 }
        when: existing_pg_secret.resources | length == 0

      - name: Set generated PostgreSQL password as facts if new secret
        set_fact:
          "{{ item.item.name }}": "{{ item.stdout }}"
        with_items: "{{ pg_random_strings.results }}"
        no_log: true
        when: existing_pg_secret.resources | length == 0

      - name: Create wire-postgresql-secret in default namespace
        kubernetes.core.k8s:
          state: present
          definition:
            apiVersion: v1
            kind: Secret
            metadata:
              name: wire-postgresql-secret
              namespace: default
              labels:
                app.kubernetes.io/name: postgresql
                app.kubernetes.io/instance: postgresql
                app.kubernetes.io/managed-by: Helm
                helm.sh/chart: postgresql-16.7.14
              annotations:
                meta.helm.sh/release-name: postgresql
                meta.helm.sh/release-namespace: default
            type: Opaque
            data:
              password: "{{ pgpassword | b64encode }}"
              postgres-password: "{{ pgadmin | b64encode }}"
          kubeconfig: "{{ kube_config }}"
        no_log: true
        when: existing_pg_secret.resources | length == 0
      
      when: "'postgresql' in charts_to_deploy"

    - name: Configure wire-server service secrets (brig, nginz, cargohold, galley)
      block:
        - name: Check if wire-server secrets file exists
          stat:
            path: "{{ wire_server_secrets_file }}"
          register: wire_server_secrets_stat

        - name: Create empty wire-server secrets file if it doesn't exist
          copy:
            content: "brig: {}\nninginz: {}\ncargohold: {}\n"
            dest: "{{ wire_server_secrets_file }}"
          when: not wire_server_secrets_stat.stat.exists

        - name: Read current secrets.yaml from remote
          slurp:
            src: "{{ wire_server_secrets_file }}"
          register: secrets_slurp

        - name: Build secrets dict for wire-server
          set_fact:
            secrets_dict:
              brig:
                secrets:
                  turn:
                    secret: "{{ zrest }}"
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
                    privateKeys: "{{ zauth_private }}"
              nginz:
                secrets:
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
              cargohold:
                secrets:
                  awsKeyId: "{{ minio_access_key }}"
                  awsSecretKey: "{{ minio_secret_key }}"
            no_log: true

        - name: Add pgPassword to update dictionary
          set_fact:
            secrets_dict: "{{ secrets_dict | combine(pg_update, recursive=True) }}"
          vars:
            pg_update:
              brig:
                secrets:
                  pgPassword: "{{ pgpassword }}"
              galley:
                secrets:
                  pgPassword: "{{ pgpassword }}"
          when: "'postgresql' in charts_to_deploy"

        - name: Update secrets in-place
          set_fact:
            secrets: "{{ (secrets_slurp.content | b64decode | from_yaml) | combine(secrets_dict, recursive=True) }}"
          no_log: true

        - name: Write updated secrets to file
          copy:
            content: "{{ secrets | to_nice_yaml }}"
            dest: "{{ wire_server_secrets_file }}"
            force: yes
          no_log: true

    - name: Configure coturn TURN server authentication secrets
      block:
      - name: Check if coturn secrets file exists
        stat:
          path: "{{ values_dir }}/coturn/secrets.yaml"
        register: coturn_secrets_stat

      - name: Create empty coturn secrets file if it doesn't exist
        copy:
          content: "secrets: {}\n"
          dest: "{{ values_dir }}/coturn/secrets.yaml"
        when: not coturn_secrets_stat.stat.exists

      - name: Read current coturn secrets from remote
        slurp:
          src: "{{ values_dir }}/coturn/secrets.yaml"
        register: coturn_slurp

      - name: Update coturn zrestSecrets
        set_fact:
          coturn_secrets: "{{ (coturn_slurp.content | b64decode | from_yaml) | combine({'secrets': {'zrestSecrets': [zrest]}}, recursive=True) }}"

      - name: Write updated coturn secrets to file
        copy:
          content: "{{ coturn_secrets | to_nice_yaml }}"
          dest: "{{ values_dir }}/coturn/secrets.yaml"

      when: "'coturn' in charts_to_deploy"

    - name: Generate Prometheus authentication credentials
      block:
      - name: Generate random string for prometheus basic auth password
        shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c 16"
        register: prom_password_output
        changed_when: false
        no_log: true

      - name: Set prometheus password as fact
        set_fact:
          prompass: "{{ prom_password_output.stdout }}"
        no_log: true

      - name: Check if kube-prometheus-stack secrets file exists
        stat:
          path: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        register: prom_secrets_stat

      - name: Create empty kube-prometheus-stack secrets file if it doesn't exist
        copy:
          content: "prometheus: {}\n"
          dest: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        when: not prom_secrets_stat.stat.exists

      - name: Read current kube-prometheus-stack secrets from remote
        slurp:
          src: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        register: prom_slurp

      - name: Update prom basic auth password
        set_fact:
          prom_secrets: "{{ (prom_slurp.content | b64decode | from_yaml) | combine({'prometheus': {'auth': {'password': prompass}}}, recursive=True) }}"

      - name: Write updated kube-prometheus-stack secrets to file
        copy:
          content: "{{ prom_secrets | to_nice_yaml }}"
          dest: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"

      when: "'kube-prometheus-stack' in additional_charts"

    - name: Cache secret hash for idempotency detection
      block:
        - name: Read secrets file from remote
          slurp:
            src: "{{ wire_server_secrets_file }}"
          register: secrets_for_hash_slurp
          no_log: true

        - name: Calculate and store hash
          copy:
            content: "{{ (secrets_for_hash_slurp.content | b64decode | from_yaml).brig.secrets.zAuth.publicKeys | hash('sha256') }}"
            dest: "{{ wire_secret_path }}"

    when: not skip_secret_generation

  - name: Secrets already up-to-date message
    debug:
      msg: "Wire secrets already up-to-date. Skipping regeneration."
    when: skip_secret_generation
