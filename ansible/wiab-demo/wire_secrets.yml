- name: Create wire secrets
  hosts: deploy_node
  vars:
    wire_server_secrets_file: "{{ values_dir }}/wire-server/secrets.yaml"
    wire_secret_path: "{{ wire_vars }}/wire_secrets"
  tasks:

  - name: Validate required variables are defined
    assert:
      that:
        - charts_to_deploy is defined
        - additional_charts is defined
        - values_dir is defined
        - kube_config is defined
      fail_msg: |
        Required variables not defined:
        - charts_to_deploy: {{ charts_to_deploy | default('UNDEFINED') }}
        - additional_charts: {{ additional_charts | default('UNDEFINED') }}
        - values_dir: {{ values_dir | default('UNDEFINED') }}
        - kube_config: {{ kube_config | default('UNDEFINED') }}
      quiet: yes

  - name: Determine secret generation skip status
    block:
    - name: Check if wire_secrets file exists
      stat:
        path: "{{ wire_secret_path }}"
      register: wire_secrets_file_stat

    - name: Read stored secret hash from file
      slurp:
        src: "{{ wire_secret_path }}"
      register: stored_secrets_hash
      when: wire_secrets_file_stat.stat.exists

    - name: Check if secrets.yaml file exists
      stat:
        path: "{{ wire_server_secrets_file }}"
      register: secrets_yaml_stat

    - name: Set skip flag to false if secrets.yaml or secret_hash file doesn't exist
      set_fact:
        skip_secret_generation: false
      when: ((not secrets_yaml_stat.stat.exists) or (not wire_secrets_file_stat.stat.exists))

    # Uses zAuth public key as idempotency marker since it uniquely identifies secret generation
    - name: Determine skip status by comparing secret hashes
      block:
      - name: Read secrets file from remote
        slurp:
          src: "{{ wire_server_secrets_file }}"
        register: secrets_file_slurp

      - name: Parse and calculate hash of Zauth Publickey
        set_fact:
          current_secret_hash: "{{ (secrets_file_slurp.content | b64decode | from_yaml).brig.secrets.zAuth.publicKeys | hash('sha256') }}"
        ignore_errors: true

      - name: Set skip flag to false if secret key is missing
        set_fact:
          skip_secret_generation: false
        when: current_secret_hash is undefined

      - name: Detect if secrets are unchanged by comparing hashes
        set_fact:
          skip_secret_generation: "{{ (stored_secrets_hash.content | b64decode | trim) == current_secret_hash }}"
        when: current_secret_hash is defined
      when:
      - secrets_yaml_stat.stat.exists
      - wire_secrets_file_stat.stat.exists

  - name: Initialize secrets.yaml files from demo templates
    block:
    - name: Discover all chart directories in values_dir for initialization
      find:
        paths: "{{ values_dir }}"
        file_type: directory
        recurse: no
      register: chart_dirs

    - name: Verify demo-secrets.example.yaml template files exist
      stat:
        path: "{{ item.path }}/demo-secrets.example.yaml"
      register: demo_secrets_stat
      loop: "{{ chart_dirs.files }}"
      no_log: true

    - name: Create timestamped backups of existing secrets.yaml files
      block:
      - name: Check if secrets.yaml file exists before backup
        stat:
          path: "{{ item.item.path }}/secrets.yaml"
        register: secrets_file_stat
        loop: "{{ demo_secrets_stat.results }}"
        no_log: true

      - name: Create backup with timestamp
        shell: |
          #!/bin/bash
          source_file="{{ item.item.path }}/secrets.yaml"
          backup_file="{{ item.item.path }}/secrets.yaml.bak.{{ lookup('pipe', 'date +%Y%m%d_%H%M%S') }}"
          if [ -f "$source_file" ]; then
            mv "$source_file" "$backup_file"
          fi
        args:
          executable: /bin/bash
        when: item.stat.exists
        loop: "{{ demo_secrets_stat.results }}"
        register: backup_result
        no_log: true

    - name: Initialize secrets.yaml from demo template for each chart
      copy:
        src: "{{ item.item.path }}/demo-secrets.example.yaml"
        dest: "{{ item.item.path }}/secrets.yaml"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ demo_secrets_stat.results }}"
      no_log: true

    when: not skip_secret_generation

  - name: Generate wire secrets and update configuration
    block:
    - name: Generate random strings for zrest, minio_access_key, and minio_secret_key
      shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c {{ item.length }}"
      register: random_strings
      changed_when: false
      with_items:
        - { name: 'zrest', length: 64 }
        - { name: 'minio_access_key', length: 20 }
        - { name: 'minio_secret_key', length: 42 }

    - name: Set generated random strings as facts
      set_fact:
        "{{ item.item.name }}": "{{ item.stdout }}"
      with_items: "{{ random_strings.results }}"
      no_log: true

    - name: Validate all secrets were generated with correct length
      assert:
        that:
          - zrest is defined and zrest | length == 64
          - minio_access_key is defined and minio_access_key | length == 20
          - minio_secret_key is defined and minio_secret_key | length == 42
        fail_msg: |
          Secret generation failed:
          - zrest length: {{ zrest | length if zrest is defined else 'UNDEFINED' }} (expected 64)
          - minio_access_key length: {{ minio_access_key | length if minio_access_key is defined else 'UNDEFINED' }} (expected 20)
          - minio_secret_key length: {{ minio_secret_key | length if minio_secret_key is defined else 'UNDEFINED' }} (expected 42)
        quiet: yes

    - name: Generate Ed25519 cryptographic keys for zauth
      block:
      - name: Create temporary directory for key files
        tempfile:
          state: directory
          suffix: _zauth_keys
        register: zauth_temp_dir
        changed_when: false

      - name: Generate Ed25519 private key in PEM format
        openssl_privatekey:
          path: "{{ zauth_temp_dir.path }}/id_ed25519"
          type: Ed25519
          force: yes
        register: ed25519_key
        no_log: true

      - name: Extract private key in DER format
        shell: "openssl pkey -in '{{ zauth_temp_dir.path }}/id_ed25519' -outform DER 2>/dev/null | base64 -w0"
        register: priv_der_b64
        changed_when: false

      - name: Extract public key in DER format
        shell: "openssl pkey -in '{{ zauth_temp_dir.path }}/id_ed25519' -pubout -outform DER 2>/dev/null | base64 -w0"
        register: pub_der_b64
        changed_when: false

      - name: Decode DER formats to get raw bytes
        set_fact:
          priv_der: "{{ priv_der_b64.stdout | b64decode }}"
          pub_der: "{{ pub_der_b64.stdout | b64decode }}"
        no_log: true

      - name: Extract private seed (last 32 bytes from private DER)
        set_fact:
          priv_seed_raw: "{{ priv_der[-32:] }}"
        no_log: true

      - name: Extract public key (last 32 bytes from public DER)
        set_fact:
          pub_key_raw: "{{ pub_der[-32:] }}"
        no_log: true

      - name: Validate extracted key byte lengths
        assert:
          that:
            - priv_seed_raw | length == 32
            - pub_key_raw | length == 32
          fail_msg: |
            Key extraction failed:
            - Private seed length: {{ priv_seed_raw | length }} (expected 32)
            - Public key length: {{ pub_key_raw | length }} (expected 32)
          quiet: yes

      - name: Combine private seed and public key for libsodium format (64 bytes total)
        set_fact:
          libsodium_combined: "{{ priv_seed_raw + pub_key_raw }}"
        no_log: true

      - name: Encode combined key to base64
        set_fact:
          zauth_private: "{{ libsodium_combined | b64encode }}"
          zauth_public: "{{ pub_key_raw | b64encode }}"
        no_log: true

      - name: Validate Ed25519 keys format and length
        assert:
          that:
            - zauth_public is defined
            - zauth_private is defined
            - zauth_public is regex('^[A-Za-z0-9+/]+=*$')
            - zauth_private is regex('^[A-Za-z0-9+/]+=*$')
            - (zauth_public | b64decode | length) == 32
            - (zauth_private | b64decode | length) == 64
          fail_msg: |
            Ed25519 key format validation failed:
            - Public key base64: {{ zauth_public }} (length: {{ zauth_public | length }})
            - Private key base64: {{ zauth_private }} (length: {{ zauth_private | length }})
            - Public key decoded length: {{ (zauth_public | b64decode | length) }} (expected 32)
            - Private key decoded length: {{ (zauth_private | b64decode | length) }} (expected 64)
            - Public key matches base64 pattern: {{ zauth_public is regex('^[A-Za-z0-9+/]+=*$') }}
            - Private key matches base64 pattern: {{ zauth_private is regex('^[A-Za-z0-9+/]+=*$') }}
          quiet: yes

      always:
      - name: Clean up temporary key files
        file:
          path: "{{ zauth_temp_dir.path }}"
          state: absent
        changed_when: false
        when: zauth_temp_dir.path is defined

    - name: Configure minio credentials for fake-aws-s3 secrets
      block:
      - name: Check if fake-aws secrets file exists
        stat:
          path: "{{ values_dir }}/fake-aws/secrets.yaml"
        register: fake_aws_secrets_stat

      - name: Create empty fake-aws secrets file if it doesn't exist
        copy:
          content: "fake-aws-s3: {}\n"
          dest: "{{ values_dir }}/fake-aws/secrets.yaml"
        when: not fake_aws_secrets_stat.stat.exists

      - name: Read fake-aws values from remote
        slurp:
          src: "{{ values_dir }}/fake-aws/secrets.yaml"
        register: fake_aws_slurp

      - name: Update minio credentials
        set_fact:
          fake_aws_values: "{{ (fake_aws_slurp.content | b64decode | from_yaml) | combine(minio_update, recursive=True) }}"
        vars:
          minio_update:
            fake-aws-s3:
              minio:
                users:
                  - accessKey: "{{ minio_access_key }}"
                    secretKey: "{{ minio_secret_key }}"
                    policy: "consoleAdmin"

      - name: Write fake-aws values to file
        copy:
          content: "{{ fake_aws_values | to_nice_yaml }}"
          dest: "{{ values_dir }}/fake-aws/secrets.yaml"

    - name: Generate PostgreSQL credentials and create Kubernetes secret
      block:
      - name: Check if wire-postgresql-secret already exists in Kubernetes
        kubernetes.core.k8s_info:
          kind: Secret
          name: wire-postgresql-secret
          namespace: default
          kubeconfig: "{{ kube_config }}"
        register: existing_pg_secret
        retries: 3
        delay: 2
        until: existing_pg_secret is not failed

      - name: Extract existing PostgreSQL credentials from Kubernetes secret
        set_fact:
          pgpassword: "{{ (existing_pg_secret.resources[0].data.password | b64decode) }}"
          pgadmin: "{{ (existing_pg_secret.resources[0].data['postgres-password'] | b64decode) }}"
        no_log: true
        when: existing_pg_secret.resources | length > 0

      - name: Generate new random strings for PostgreSQL passwords if secret doesn't exist
        shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c {{ item.length }}"
        register: pg_random_strings
        changed_when: false
        no_log: true
        with_items:
          - { name: 'pgpassword', length: 32 }
          - { name: 'pgadmin', length: 32 }
        when: existing_pg_secret.resources | length == 0

      - name: Set generated PostgreSQL password as facts if new secret
        set_fact:
          "{{ item.item.name }}": "{{ item.stdout }}"
        with_items: "{{ pg_random_strings.results }}"
        no_log: true
        when: existing_pg_secret.resources | length == 0

      - name: Create wire-postgresql-secret in default namespace
        kubernetes.core.k8s:
          state: present
          definition:
            apiVersion: v1
            kind: Secret
            metadata:
              name: wire-postgresql-secret
              namespace: default
              labels:
                app.kubernetes.io/name: postgresql
                app.kubernetes.io/instance: postgresql
                app.kubernetes.io/managed-by: Helm
                helm.sh/chart: postgresql-16.7.14
              annotations:
                meta.helm.sh/release-name: postgresql
                meta.helm.sh/release-namespace: default
            type: Opaque
            data:
              password: "{{ pgpassword | b64encode }}"
              postgres-password: "{{ pgadmin | b64encode }}"
          kubeconfig: "{{ kube_config }}"
        no_log: true
        when: existing_pg_secret.resources | length == 0
      
      when: "'postgresql' in charts_to_deploy"

    - name: Configure wire-server service secrets (brig, nginz, cargohold, galley)
      block:
        - name: Check if wire-server secrets file exists
          stat:
            path: "{{ wire_server_secrets_file }}"
          register: wire_server_secrets_stat

        - name: Create empty wire-server secrets file if it doesn't exist
          copy:
            content: "brig: {}\nninginz: {}\ncargohold: {}\n"
            dest: "{{ wire_server_secrets_file }}"
          when: not wire_server_secrets_stat.stat.exists

        - name: Read current secrets.yaml from remote
          slurp:
            src: "{{ wire_server_secrets_file }}"
          register: secrets_slurp

        - name: Build secrets dict for wire-server
          set_fact:
            secrets_dict:
              brig:
                secrets:
                  turn:
                    secret: "{{ zrest }}"
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
                    privateKeys: "{{ zauth_private }}"
              nginz:
                secrets:
                  zAuth:
                    publicKeys: "{{ zauth_public }}"
              cargohold:
                secrets:
                  awsKeyId: "{{ minio_access_key }}"
                  awsSecretKey: "{{ minio_secret_key }}"
            no_log: true

        - name: Add pgPassword to update dictionary
          set_fact:
            secrets_dict: "{{ secrets_dict | combine(pg_update, recursive=True) }}"
          vars:
            pg_update:
              brig:
                secrets:
                  pgPassword: "{{ pgpassword }}"
              galley:
                secrets:
                  pgPassword: "{{ pgpassword }}"
          when: "'postgresql' in charts_to_deploy"

        - name: Update secrets in-place
          set_fact:
            secrets: "{{ (secrets_slurp.content | b64decode | from_yaml) | combine(secrets_dict, recursive=True) }}"
          no_log: true

        - name: Write updated secrets to file
          copy:
            content: "{{ secrets | to_nice_yaml }}"
            dest: "{{ wire_server_secrets_file }}"
            force: yes
          no_log: true

    - name: Configure coturn TURN server authentication secrets
      block:
      - name: Check if coturn secrets file exists
        stat:
          path: "{{ values_dir }}/coturn/secrets.yaml"
        register: coturn_secrets_stat

      - name: Create empty coturn secrets file if it doesn't exist
        copy:
          content: "secrets: {}\n"
          dest: "{{ values_dir }}/coturn/secrets.yaml"
        when: not coturn_secrets_stat.stat.exists

      - name: Read current coturn secrets from remote
        slurp:
          src: "{{ values_dir }}/coturn/secrets.yaml"
        register: coturn_slurp

      - name: Update coturn zrestSecrets
        set_fact:
          coturn_secrets: "{{ (coturn_slurp.content | b64decode | from_yaml) | combine({'secrets': {'zrestSecrets': [zrest]}}, recursive=True) }}"

      - name: Write updated coturn secrets to file
        copy:
          content: "{{ coturn_secrets | to_nice_yaml }}"
          dest: "{{ values_dir }}/coturn/secrets.yaml"

      when: "'coturn' in charts_to_deploy"

    - name: Generate Prometheus authentication credentials
      block:
      - name: Generate random string for prometheus basic auth password
        shell: "tr -dc A-Za-z0-9 </dev/urandom | head -c 16"
        register: prom_password_output
        changed_when: false
        no_log: true

      - name: Set prometheus password as fact
        set_fact:
          prompass: "{{ prom_password_output.stdout }}"
        no_log: true

      - name: Check if kube-prometheus-stack secrets file exists
        stat:
          path: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        register: prom_secrets_stat

      - name: Create empty kube-prometheus-stack secrets file if it doesn't exist
        copy:
          content: "prometheus: {}\n"
          dest: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        when: not prom_secrets_stat.stat.exists

      - name: Read current kube-prometheus-stack secrets from remote
        slurp:
          src: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"
        register: prom_slurp

      - name: Update prom basic auth password
        set_fact:
          prom_secrets: "{{ (prom_slurp.content | b64decode | from_yaml) | combine({'prometheus': {'auth': {'password': prompass}}}, recursive=True) }}"

      - name: Write updated kube-prometheus-stack secrets to file
        copy:
          content: "{{ prom_secrets | to_nice_yaml }}"
          dest: "{{ values_dir }}/kube-prometheus-stack/secrets.yaml"

      when: "'kube-prometheus-stack' in additional_charts"

    - name: Cache secret hash for idempotency detection
      block:
        - name: Read secrets file from remote
          slurp:
            src: "{{ wire_server_secrets_file }}"
          register: secrets_for_hash_slurp
          no_log: true

        - name: Calculate and store hash
          copy:
            content: "{{ (secrets_for_hash_slurp.content | b64decode | from_yaml).brig.secrets.zAuth.publicKeys | hash('sha256') }}"
            dest: "{{ wire_secret_path }}"

    when: not skip_secret_generation

  - name: Secrets already up-to-date message
    debug:
      msg: "Wire secrets already up-to-date. Skipping regeneration."
    when: skip_secret_generation
