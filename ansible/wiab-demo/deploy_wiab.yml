- name: Execute common tasks for the node
  hosts: deploy_node
  tags: always
  tasks:
  # if number of nodes increase, the logic can be adapted to change nodes for different services
  # currently it is pointing to the first node
  - name: Set facts for various Kubernetes nodes (for a single node), it will be name of profile
    set_fact:
      k8s_ingress_controller_node: "{{ minikube_profile }}"
      k8s_coturn_node: "{{ minikube_profile }}"
      k8s_sft_node: "{{ minikube_profile }}"
      iptables_rules_comment: "Wire Iptables Rules"
      iptables_save_dir: "/home/{{ ansible_user }}/wire-iptables-rules"
      kube_config: "/home/{{ ansible_user }}/.kube/config"
      values_dir: "{{ ansible_user_dir }}/wire-server-deploy/values"
      charts_dir: "{{ ansible_user_dir }}/wire-server-deploy/charts"
      wire_vars: "{{ ansible_user_dir }}/wire_vars"

  - name: Create wire_vars directory if it doesn't exist
    file:
      path: "{{ wire_vars }}"
      state: directory

# shouldn't be skipped, it is neccessary to identify the network ingress
# potentially we can write the information on the node to avoid running it everytime
# read it from the node if not found
- name: Check Wire IP access
  import_playbook: ./verify_wire_ip.yml
  tags: always

- name: Verify the dns records before starting to install
  import_playbook: ./verify_dns.yml
  tags: verify_dns

- name: Install required packages
  import_playbook: ./install_pkgs.yml
  tags: install_pkgs

- name: Check and configure Ansible Python interpreter for Kubernetes operations
  tags: always
  hosts: deploy_node
  tasks:
  - name: Detect available Python interpreters and Kubernetes module
    block:
    - name: Check if kubernetes module is available in system Python
      shell: "python3 -c 'import kubernetes; print(kubernetes.__version__)' 2>/dev/null"
      register: system_k8s_check
      changed_when: false
      failed_when: false

    - name: Check virtual environment only if system Python doesn't have kubernetes
      block:
      - name: Check if kubernetes module is available in virtual environment
        shell: "/opt/ansible-venv/bin/python -c 'import kubernetes; print(kubernetes.__version__)' 2>/dev/null"
        register: venv_k8s_check
        changed_when: false
        failed_when: false

      - name: Configure to use virtual environment
        block:
        - name: Set ansible_python_interpreter to use virtual environment
          set_fact:
            ansible_python_interpreter: /opt/ansible-venv/bin/python
            ansible_venv_path: /opt/ansible-venv

        when: venv_k8s_check.rc == 0

      - name: Kubernetes module not found - run install_pkgs playbook
        fail:
          msg: |
            âŒ Kubernetes Python module not found!
            
            System Python (/usr/bin/python3):
              Status: NOT available
              
            Virtual Environment (/opt/ansible-venv/bin/python):
              Status: NOT available
              
            To install kubernetes module, run:
            ansible-playbook -i inventory.yml deploy_wiab.yml --tags install_pkgs
        when: venv_k8s_check.rc != 0

      when: system_k8s_check.rc != 0

- name: Manage SSH keys (dependency for minikube, asset_host, seed_containers)
  import_playbook: ./setup_ssh.yml
  tags: always
  when: >
    ('minikube' not in ansible_skip_tags or
    'asset_host' not in ansible_skip_tags or
    'seed_containers' not in ansible_skip_tags)
    and
    ('all' in ansible_run_tags or
    'minikube' in ansible_run_tags or
    'asset_host' in ansible_run_tags or
    'seed_containers' in ansible_run_tags)

- name: Configure minikube cluster
  import_playbook: ./minikube_cluster.yml
  tags: minikube

- name: Set k8s related ansible inventory
  hosts: deploy_node
  become: yes
  become_user: "{{ ansible_user }}"
  tasks:
  - name: Setting up inventory
    block:
    - name: Get the IP address of the k8s_ingress_controller node
      kubernetes.core.k8s_info:
        kind: Node
        name: "{{ k8s_ingress_controller_node }}"
        kubeconfig: "{{ kube_config }}"
      register: ingress_controller_node_info
      retries: 3
      delay: 2
      until: ingress_controller_node_info is succeeded

    - name: Extract internal IP from k8s_ingress_controller node
      set_fact:
        k8s_ingress_controller_ip: "{{ ingress_controller_node_info.resources[0].status.addresses | selectattr('type', 'equalto', 'InternalIP') | map(attribute='address') | first }}"
      when: ingress_controller_node_info.resources | length > 0

    - name: Get the {{ minikube_network_name }} Docker network ID
      shell: |
        docker network inspect {{ minikube_network_name }} | jq -r '.[0].Id'
      register: docker_network_id
      changed_when: false

    - name: Get all interfaces with bridge interfaces
      shell: ip -o addr show | awk '{print $2}' | grep -i 'br-'
      register: bridge_interfaces
      changed_when: false

    - name: Find the matching bridge interface for {{ minikube_network_name }} Docker network
      shell: |
        for iface in {{ bridge_interfaces.stdout_lines | join(' ') }}; do
          iface_id=$(echo "$iface" | cut -d '-' -f2)
          if echo "{{ docker_network_id.stdout }}" | grep -q "$iface_id"; then
            echo "$iface"
            break
          fi
        done
      register: matching_bridge_interface
      changed_when: false

    - name: set facts for k8s ingress controller ip
      set_fact:
        matching_bridge_interface: "{{ matching_bridge_interface.stdout }}"

    tags: always
    when: >
      ('minikube' not in ansible_skip_tags or
      'asset_host' not in ansible_skip_tags or
      'seed_containers' not in ansible_skip_tags or
      'helm_install' not in ansible_skip_tags)
      and
      ('all' in ansible_run_tags or
      'minikube' in ansible_run_tags or
      'asset_host' in ansible_run_tags or
      'seed_containers' in ansible_run_tags or
      'helm_install' in ansible_run_tags)

- name: Configure Iptables rules
  import_playbook: ./iptables_rules.yml
  tags: minikube

- name: Download wire artifact
  import_playbook: ./download_artifact.yml
  tags: download

- name: Add minikube nodes to ansible inventory
  hosts: deploy_node
  become: yes
  become_user: "{{ ansible_user }}"
  tags: always
  tasks:
  - name: Create a block for Minikube node tasks
    block:
    - name: Extract IPs of Minikube nodes
      kubernetes.core.k8s_info:
        kind: Node
        kubeconfig: "{{ kube_config }}"
      register: nodes_info
      retries: 3
      delay: 2
      until: nodes_info is succeeded

    - name: Extract InternalIP addresses from all nodes
      set_fact:
        kubernetes_node_ips: "{{ nodes_info.resources | map(attribute='status.addresses') | map('selectattr', 'type', 'equalto', 'InternalIP') | map('map', attribute='address') | map('first') | list }}"

    - name: Extract IP of "{{ minikube_network_name }}" interface on host machine
      shell: |
        docker network inspect "{{ minikube_network_name }}" | jq -r '.[0].IPAM.Config[0].Gateway'
      register: host_ip

    - name: Create a temporary directory
      tempfile:
        state: directory
        suffix: _ssh_keys
      register: temp_dir
      delegate_to: localhost
      become: no

    - name: Debug message for private key writing
      ansible.builtin.debug:
        msg: "Creating a key {{ temp_dir.path }}/id_rsa_wire on the localhost to enable access to minikube nodes via ssh proxy"

    - name: Write the private key to a file
      copy:
        content: "{{ ssh_private_key }}"
        dest: "{{ temp_dir.path }}/id_rsa_wire"
        mode: '0600'
      delegate_to: localhost
      become: no

    - name: Add containers to inventory
      become: yes
      become_user: "{{ ansible_user }}"
      add_host:
        name: "{{ item }}"
        groups: k8s-cluster
        ansible_user: docker
        ansible_ssh_common_args: >-
          -o ProxyCommand="ssh {% if ansible_ssh_private_key_file is defined %}-i {{ ansible_ssh_private_key_file }}{% endif %}
          -o StrictHostKeyChecking=no
          -o UserKnownHostsFile=/dev/null
          -W %h:%p -q {{ ansible_user }}@{{ ansible_host }}"
          -o StrictHostKeyChecking=no
          -o UserKnownHostsFile=/dev/null
          -i {{ temp_dir.path }}/id_rsa_wire
          -o BatchMode=yes
      loop: "{{ kubernetes_node_ips }}"

    - name: Define inventory for the assethost to match the hostname in setup-offline-sources.yml
      become: yes
      become_user: "{{ ansible_user }}"
      add_host:
        name: "{{ host_ip.stdout }}"
        group: assethost
        ansible_user: "{{ ansible_user }}"
        ansible_ssh_common_args: >-
          -o ProxyCommand="ssh {% if ansible_ssh_private_key_file is defined %}-i {{ ansible_ssh_private_key_file }}{% endif %}
          -o StrictHostKeyChecking=no
          -o UserKnownHostsFile=/dev/null
          -W %h:%p -q {{ ansible_user }}@{{ ansible_host }}"
          -o StrictHostKeyChecking=no
          -o UserKnownHostsFile=/dev/null
          -o BatchMode=yes
          {% if ansible_ssh_private_key_file is defined %}-i {{ ansible_ssh_private_key_file }}{% endif %}

    - name: Set assethost_host fact for each node in k8s-cluster
      set_fact:
        assethost_host: "{{ host_ip.stdout }}:8080"
      delegate_to: "{{ item }}"
      delegate_facts: true
      with_items: "{{ groups['k8s-cluster'] }}"

    when: >
      ('asset_host' not in ansible_skip_tags or
      'seed_containers' not in ansible_skip_tags)
      and
      ('all' in ansible_run_tags or
      'asset_host' in ansible_run_tags or
      'seed_containers' in ansible_run_tags)

- name: Setup Asset Host
  import_playbook: ../setup-offline-sources.yml
  vars:
    demo_deploy: true
    remote_src: yes
    src_path: "/home/{{ ansible_user }}/wire-server-deploy"
  tags: asset_host

- name: Seed the containers in k8s-cluster nodes
  import_playbook: ../seed-offline-containerd.yml
  vars:
    docker_permission_fix: true
    skip_seed_system_containers: true
  tags: seed_containers

- name: Prepare helm chart values
  import_playbook: ./wire_values.yml
  tags: 
    - wire_values

- name: Create wire secrets
  import_playbook: ./wire_secrets.yml
  tags: wire_secrets

- name: Install Helm charts
  import_playbook: ./helm_install.yml
  tags: helm_install

# since, the temp_dir are created in a different set of tasks, these directories need to be searched 
- name: Clean up temporary directories
  hosts: localhost
  tags: cleanup
  tasks:
    - name: Find all temporary directories
      find:
        paths: /tmp
        patterns: "ansible.*_ssh_keys"
        file_type: directory
      register: temp_dirs

    - name: List all temporary directories
      debug:
        msg: "Found temporary directory: {{ item.path }}"
      loop: "{{ temp_dirs.files }}"
      loop_control:
        label: "{{ item.path }}"

    - name: Delete all temporary directories
      file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ temp_dirs.files }}"
      loop_control:
        label: "{{ item.path }}"

- name: Stop and disable serve-assets systemd service post deployment
  hosts: deploy_node
  tags: cleanup
  become: yes
  tasks:
  - name: Stop and disable serve-assets service
    systemd:
      name: serve-assets
      state: stopped
      enabled: no
    ignore_errors: yes
