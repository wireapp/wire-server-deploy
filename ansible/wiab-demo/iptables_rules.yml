- name: Configure Iptable rules
  hosts: deploy_node
  become: yes
  tasks:
  - name: Ensure iptables directory exists
    file:
      path: "{{ iptables_save_dir }}"
      state: directory
      owner: root
      group: root
      mode: '0755'

  - name: Enable bridge netfilter for iptables
    sysctl:
      name: net.bridge.bridge-nf-call-iptables
      value: "1"
      state: present
      sysctl_set: true
      reload: true

  # incase, this pipeline is running again, we try to preserve initial state
  - name: Check if pre_wire IPv4 ruleset file exists
    stat:
      path: "{{ iptables_save_dir }}/rules_pre_wire.v4"
    register: rules_file

  - name: Restore pre_wire IPv4 ruleset
    shell: iptables-restore < "{{ iptables_save_dir }}/rules_pre_wire.v4"
    when: rules_file.stat.exists

  - name: Save iptables rules
    shell: iptables-save -f "{{ iptables_save_dir }}"/rules_pre_wire.v4

  - name: Configure DNAT rules to send http/https traffic to the k8s ingress controller
    iptables:
      table: nat
      chain: PREROUTING
      protocol: "{{ item.protocol }}"
      jump: DNAT
      in_interface: "{{ default_interface }}"
      destination: "{{ default_interface_ip }}"
      destination_port: "{{ item.port }}"
      to_destination: "{{ k8s_ingress_controller_ip }}:{{ item.to_port }}"
      state: present
      action: insert
      comment: "{{ iptables_rules_comment }}"
    loop: "{{ http_dnat_rules }}"
    loop_control:
      label: "Setting DNAT rule for port {{ item.port }} -> {{ k8s_ingress_controller_ip | default('undefined') }}:{{ item.to_port }}"
    
  - name: Ensure FORWARD rule for traffic from main interface to ingress controller
    iptables:
      table: filter
      chain: FORWARD
      in_interface: "{{ default_interface }}"
      out_interface: "{{ matching_bridge_interface }}"
      jump: ACCEPT
      state: present
      action: insert
      comment: "{{ iptables_rules_comment }}"

  - name: Ensure FORWARD rule for traffic from ingress controller to main interface
    iptables:
      table: filter
      chain: FORWARD
      in_interface: "{{ matching_bridge_interface }}"
      out_interface: "{{ default_interface }}"
      jump: ACCEPT
      state: present
      action: insert
      comment: "{{ iptables_rules_comment }}"

  - name: Get the IP address of the coturn node
    shell: |
      kubectl --kubeconfig="{{ kube_config_path }}" get node {{ k8s_coturn_node }} -o json | jq -r '.status.addresses[] | select(.type=="InternalIP").address'
    register: k8s_coturn_node_ip
    changed_when: false

  - name: Display k8s_coturn_node
    debug:
      msg: "coturn node: {{ k8s_coturn_node }}, ip: {{ k8s_coturn_node_ip }}"

  - name: Configure DNAT rule to send UDP calling traffic for coturn/sftd pods on the k8s node
    iptables:
      table: nat
      chain: PREROUTING
      protocol: udp
      jump: DNAT
      destination: "{{ default_interface_ip }}"
      destination_ports: "32768:65535"
      in_interface: "{{ default_interface }}"
      to_destination: "{{ k8s_coturn_node_ip.stdout }}"
      state: present
      action: insert
      comment: "{{ iptables_rules_comment }}"

  - name: Configure DNAT rules to reach coturn servers running on k8s node
    iptables:
      table: nat
      chain: PREROUTING
      protocol: "{{ item.protocol }}"
      jump: DNAT
      in_interface: "{{ default_interface }}"
      destination: "{{ default_interface_ip }}"
      destination_port: "{{ item.port }}"
      to_destination: "{{ k8s_coturn_node_ip.stdout }}:{{ item.to_port }}"
      state: present
      action: insert
      comment: "{{ iptables_rules_comment }}"
    loop: "{{ turn_dnat_rules }}"
    loop_control:
      label: "Setting DNAT rule for port {{ item.port }} -> {{ k8s_coturn_node_ip.stdout | default('undefined') }}:{{ item.to_port }}"

  - name: Preserve the Iptables rules
    shell: iptables-save -f "{{ iptables_save_dir }}"/rules_post_wire.v4
